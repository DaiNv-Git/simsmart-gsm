package app.simsmartgsm.service;

import app.simsmartgsm.entity.Sim;
import app.simsmartgsm.repository.SimRepository;
import app.simsmartgsm.uitils.AtCommandHelper;
import com.fazecast.jSerialComm.SerialPort;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.net.InetAddress;
import java.time.Instant;
import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class SimSyncService {

    private final SimRepository simRepository;

    /**
     * Lu·ªìng ch√≠nh: scan t·∫•t c·∫£ COM -> l∆∞u DB -> resolve s·ªë ƒëi·ªán tho·∫°i cho SIM ch∆∞a c√≥ s·ªë.
     */
    public void syncAndResolve() throws Exception {
        String deviceName = InetAddress.getLocalHost().getHostName();
        log.info("=== B·∫ÆT ƒê·∫¶U SCAN cho deviceName={} ===", deviceName);

        // 1. Scan t·∫•t c·∫£ COM
        List<ScannedSim> scanned = scanAllPorts();

        // 2. L∆∞u DB
        syncScannedToDb(deviceName, scanned);

        // 3. Ch·ªçn receiver
        List<ScannedSim> known = scanned.stream()
                .filter(s -> s.phoneNumber != null && !s.phoneNumber.isBlank())
                .toList();

        List<ScannedSim> unknown = scanned.stream()
                .filter(s -> s.phoneNumber == null || s.phoneNumber.isBlank())
                .toList();

        if (known.isEmpty()) {
            log.warn("‚ùå Kh√¥ng c√≥ SIM n√†o c√≥ s·ªë ƒëi·ªán tho·∫°i. B·ªè qua b∆∞·ªõc resolve.");
            return;
        }

        ScannedSim receiver = known.get(0);
        log.info("Receiver ch·ªçn: com={} phone={}", receiver.comName, receiver.phoneNumber);

        // 4. Resolve cho c√°c SIM ch∆∞a bi·∫øt s·ªë
        resolvePhoneNumbers(deviceName, unknown, receiver);
    }

    private List<ScannedSim> scanAllPorts() {
        List<ScannedSim> scanned = new ArrayList<>();
        SerialPort[] ports = SerialPort.getCommPorts();
        log.info("T√¨m th·∫•y {} c·ªïng COM", ports.length);

        for (SerialPort port : ports) {
            String com = port.getSystemPortName();
            try (AtCommandHelper helper = new AtCommandHelper(port)) {
                helper.ping();
                String ccid = helper.getCcid();
                String imsi = helper.getImsi();
                String phone = helper.getCnum();

                ScannedSim s = new ScannedSim(com, ccid, imsi, phone, detectProvider(imsi));
                scanned.add(s);

                log.info("‚úÖ Scan {} -> ccid={} imsi={} phone={}", com, ccid, imsi, phone);
            } catch (Exception ex) {
                log.warn("‚ùå L·ªói scan port {}: {}", com, ex.getMessage());
            }
        }
        return scanned;
    }

    private void syncScannedToDb(String deviceName, List<ScannedSim> scanned) {
        for (ScannedSim ss : scanned) {
            if (ss.ccid == null) continue;

            Sim sim = simRepository.findByDeviceNameAndCcid(deviceName, ss.ccid)
                    .orElse(Sim.builder().ccid(ss.ccid).deviceName(deviceName).comName(ss.comName).build());

            sim.setImsi(ss.imsi);
            sim.setComName(ss.comName);
            sim.setPhoneNumber(ss.phoneNumber);
            sim.setSimProvider(ss.simProvider);
            sim.setStatus("active");
            sim.setLastUpdated(Instant.now());

            simRepository.save(sim);
        }

        // ƒë√°nh d·∫•u replaced cho sim m·∫•t
        Set<String> scannedCcids = scanned.stream().map(s -> s.ccid).filter(Objects::nonNull).collect(Collectors.toSet());
        simRepository.findByDeviceName(deviceName).forEach(db -> {
            if (db.getCcid() != null && !scannedCcids.contains(db.getCcid())) {
                db.setStatus("replaced");
                db.setLastUpdated(Instant.now());
                simRepository.save(db);
                log.info("‚ö†Ô∏è SIM {} (com={}) ƒë√°nh d·∫•u replaced", db.getCcid(), db.getComName());
            }
        });
    }

    private void resolvePhoneNumbers(String deviceName, List<ScannedSim> unknown, ScannedSim receiver) {
        for (ScannedSim sim : unknown) {
            String token = "CHECK-" + UUID.randomUUID().toString().substring(0, 6);
            log.info("üëâ G·ª≠i token={} t·ª´ {} -> {}", token, sim.comName, receiver.phoneNumber);

            boolean sent = sendSmsFromPort(sim.comName, receiver.phoneNumber, token);
            if (!sent) continue;

            String found = pollReceiverForToken(receiver.comName, token, 20_000);
            if (found != null) {
                log.info("‚úÖ Resolve th√†nh c√¥ng: com={} ccid={} phone={}", sim.comName, sim.ccid, found);

                Sim dbSim = simRepository.findByDeviceNameAndCcid(deviceName, sim.ccid)
                        .orElse(Sim.builder().ccid(sim.ccid).deviceName(deviceName).comName(sim.comName).build());
                dbSim.setPhoneNumber(found);
                dbSim.setStatus("active");
                dbSim.setLastUpdated(Instant.now());
                simRepository.save(dbSim);
            }
        }
    }

    private boolean sendSmsFromPort(String fromCom, String toNumber, String token) {
        try (AtCommandHelper helper = new AtCommandHelper(SerialPort.getCommPort(fromCom))) {
            return helper.sendTextSms(toNumber, token, java.time.Duration.ofSeconds(15));
        } catch (Exception e) {
            log.error("G·ª≠i SMS l·ªói t·ª´ {}: {}", fromCom, e.getMessage());
            return false;
        }
    }

    private String pollReceiverForToken(String receiverCom, String token, long timeoutMs) {
        long start = System.currentTimeMillis();
        while (System.currentTimeMillis() - start < timeoutMs) {
            try (AtCommandHelper helper = new AtCommandHelper(SerialPort.getCommPort(receiverCom))) {
                var unread = helper.listUnreadSmsText(3000);
                for (var sms : unread) {
                    if (sms.body != null && sms.body.contains(token)) {
                        return sms.sender;
                    }
                }
            } catch (Exception e) {
                log.error("ƒê·ªçc inbox receiver {} l·ªói: {}", receiverCom, e.getMessage());
            }
            try { Thread.sleep(2000); } catch (InterruptedException ignored) {}
        }
        return null;
    }

    private String detectProvider(String imsi) {
        if (imsi == null) return null;
        if (imsi.startsWith("44010")) return "NTT Docomo (JP)";
        if (imsi.startsWith("44011")) return "Rakuten Mobile (JP)";
        if (imsi.startsWith("45204") || imsi.startsWith("45205")) return "Viettel (VN)";
        return "Unknown";
    }

    private record ScannedSim(String comName, String ccid, String imsi, String phoneNumber, String simProvider) {}
}
